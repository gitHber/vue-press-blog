<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>es5实现继承 | Hello vuepress</title>
    <meta name="description" content="Just play nothing">
    
    
    <link rel="preload" href="/vue-press-blog/assets/css/0.styles.e81dda9c.css" as="style"><link rel="preload" href="/vue-press-blog/assets/js/app.e30d7fb3.js" as="script"><link rel="preload" href="/vue-press-blog/assets/js/3.dff82318.js" as="script"><link rel="prefetch" href="/vue-press-blog/assets/js/2.61c5963e.js"><link rel="prefetch" href="/vue-press-blog/assets/js/4.9a612935.js">
    <link rel="stylesheet" href="/vue-press-blog/assets/css/0.styles.e81dda9c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/vue-press-blog/" class="home-link router-link-exact-active router-link-active"><!----><span class="site-name">
      Hello vuepress
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><!----></div><div class="page"><div class="content"><h1 id="es5实现继承">es5实现继承</h1><ul><li>父类实现</li></ul><div class="language- extra-class"><pre class="language-text"><code>// 定义一个动物类
function Animal(name){
    this.name = name || 'Animal'
    this.sleep = function(){
        console.log(this.name+'正在睡觉')
    }
}
// 原型方法
Animal.prototype.eat = function(food){
    console.log(this.name+'正在吃'+food)
}
</code></pre></div><h4 id="_1-原型链继承">1.原型链继承</h4><div class="language- extra-class"><pre class="language-text"><code>function Cat(){
}
Cat.prototype = new Animal()
Cat.prototype.name = 'cat'

// Test code
var cat = new Cat()
console.log(cat.name) // cat
console.log(cat.eat('fish'));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
</code></pre></div><ul><li>缺点</li></ul><ol><li>新增原型方法，必须先指向父类的实例</li><li>不能多继承</li><li>原型对象的引用属性共享</li></ol><h4 id="_2-构造继承">2.构造继承</h4><div class="language- extra-class"><pre class="language-text"><code>function Cat(name){
    Animal.call(this)
    this.name = name || 'Tom'
}
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre></div><ul><li>特点</li></ul><ol><li>引用属性不在公用</li><li>可以多继承</li></ol><ul><li>缺点</li></ul><ol><li>实例不是父类的实例</li><li>不能继承原型方法</li><li>无法实现函数复用，每个字类都有父类实例函数的副本，影响性能</li></ol><h4 id="_3-实例继承">3.实例继承</h4><div class="language- extra-class"><pre class="language-text"><code>function Cat(name){
    var instance = new Animal()
    instance.name = name || 'Tom'
    return instance
}
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
</code></pre></div><ul><li>缺点</li></ul><ol><li>实例是父类的实例</li><li>不支持多继承</li></ol><h4 id="_4-拷贝继承">4.拷贝继承</h4><div class="language- extra-class"><pre class="language-text"><code>function Cat(name){
    var animal = new Animal()
    for(var p in animal){
        Cat.prototype[p] = animal[p]
    }
    Cat.prototype.name = name || 'Tom'
}
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre></div><ul><li>缺点</li></ul><ol><li>效率低</li><li>不支持枚举的属性，无法继承</li></ol><h4 id="_5-组合继承">5.组合继承</h4><div class="language- extra-class"><pre class="language-text"><code>function Cat(name){
    Animal.call(this)
    this.name = name || Tom
}
Cat.prototype = new Animal()
Cat.prototype = Cat
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
</code></pre></div><ul><li>缺点</li></ul><ol><li>调用了两次父类构造函数，生成两份实例</li></ol><h4 id="_6-寄生组合继承">6. 寄生组合继承</h4><div class="language- extra-class"><pre class="language-text"><code>function Cat(name){
    Animal.call(this)
    this.name = name || 'Tom'
}
(function(){
    var Super = function(){}
    Super.prototype = Animal.prototype
    Cat.prototype = new Super()
    Cat.prototype.constructor = Cat
})()
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
</code></pre></div><ul><li>实现复杂</li></ul></div><div class="page-edit"><!----><!----></div><!----></div></div></div>
    <script src="/vue-press-blog/assets/js/3.dff82318.js" defer></script><script src="/vue-press-blog/assets/js/app.e30d7fb3.js" defer></script>
  </body>
</html>
